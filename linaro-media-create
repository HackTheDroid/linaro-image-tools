#!/bin/bash
# linaro-media-create - Create an installation media from a Linaro image

# Copyright 2010 Robert Nelson <robertcnelson@gmail.com>
# Copyright 2010 Linaro
# Based on rcn's setup_sdcard.sh script.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 3 as published
# by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

set -e

unset DEVICE BOOTFS ROOTFS IMAGE_FILE HWPACK_FILES UBOOT_FLAVOR KERNEL_ADDR
unset INITRD_ADDR CREATE_SWAP SWAP_SIZE DEPLOY_STEPS

declare -a HWPACK_FILES

#Defaults
RFS=ext3
BINARY_TARBALL='binary-tar.tar.gz'
BOOT_LABEL=boot
RFS_LABEL=rootfs
IS_LIVE=0
IS_LOWMEM=0
FAT_SIZE=32
IMAGE_SIZE=2G
MMC_PART_OFFSET=0
BOOTFS_STEP="create_boot_cmd populate_boot"
ROOTFS_STEP="populate_rootfs"
SHOULD_CREATE_PARTITIONS="yes"
mmc_option="0:1"
boot_args_options="rootwait ro"
HWPACK_FORCE_YES="no"

DIR=$PWD
TMP_DIR=$(mktemp -d)
cleanup_tempfiles() {
  rm -r "$TMP_DIR"

  cleanup_tempfiles() { :; }
}

BOOT_DISK="${DIR}/boot-disc"
ROOT_DISK="${DIR}/root-disc"

cleanup_mountpoints() {

  local dir

  for dir in "$BOOT_DISK" "$ROOT_DISK"; do
    if [ -d "$dir" ]; then
      rmdir -v "$dir"
    fi
  done

}

# Make sure other scripts are called from the correct place when running this
# off of a l-m-c working tree.
script_dir=$(dirname "$(readlink -f "$0")")
PATH="${script_dir}:$PATH"

# Also make sure the necessary python modules are available when running this
# off of a l-m-c working tree.
export PYTHONPATH="$script_dir"

python -m media_create.ensure_command sfdisk util-linux
python -m media_create.ensure_command fdisk util-linux

usage() {
  echo "usage: $(basename $0) --mmc /dev/sdd"
  echo "<or>"
  echo "usage: $(basename $0) --image_file mmc.img"
  cat <<EOF

required options:
--mmc </dev/sdX>
    Unformatted Storage Device
<or>
--image_file <xxx>
    specify name of image file

--dev <board>
    use development boot options; this includes setting up serial ttys as well
    as enabling normal debug options for the target board. Current board values:
    * beagle
    * igep
    * mx51evk
    * panda
    * ux500
    * vexpress

Additional/Optional options:
-h --help
    this help

--rootfs <fs_type>
    ext2
    ext3 - <set as default>
    ext4
    btrfs

--boot_label <boot_label>
    boot partition label

--rfs_label <rfs_label>
    rootfs partition label

--swap_file <xxx>
    Creats a Swap file of (xxx)MB's

--live
    Create boot command for casper/live images; if this is not
    provided a UUID for the rootfs is generated and used as the root=
    option

--live-256m
    Create boot command for casper/live images; adds only-ubiquity option
    to allow use of live installer on boards with 256M memory - like beagle

--console <ttyXY>
    add a console to kernel boot parameter; this parameter can be defined
    multiple times.

--hwpack <filename>
    A hardware pack that should be installed in the rootfs.

--image_size nnnG or nnnM
    specify size of SD image to create; use with --image_file only (default: 2G)

--binary <filename>
    specify file used to create the bootable system. Default binary-tar.tar.gz

--no-rootfs
    do not deploy the root filesystem

--no-bootfs
    do not deploy the boot filesystem

--no-part
    reuse existing partitions on the deploy media
EOF
  exit
}

check_device() {
  FDISK=$(sudo LC_ALL=C fdisk -l 2>/dev/null | grep "Disk ${DEVICE}" | awk '{print $2}')

  if test "-$FDISK-" = "-$DEVICE:-"
  then
    echo ""
    echo "I see..."
    echo "sudo fdisk -l:"
    sudo LC_ALL=C fdisk -l 2>/dev/null | grep "Disk /dev/" --color=never
    echo ""
    echo "mount:"
    LC_ALL=C mount | grep -v none | grep "/dev/" --color=never
    echo ""
    read -p "Are you 100% sure, on selecting [${DEVICE}] (y/n)? "
    [ "$REPLY" == "y" ] || exit
    echo ""
  else
    echo ""
    echo "Are you sure? I Don't see [${DEVICE}], here is what I do see..."
    echo ""
    echo "sudo fdisk -l:"
    sudo LC_ALL=C fdisk -l 2>/dev/null| grep "Disk /dev/" --color=never
    echo ""
    echo "mount:"
    LC_ALL=C mount | grep -v none | grep "/dev/" --color=never
    echo ""
    exit
  fi
}

check_fs_type() {
  case "$RFS" in
    ext2|ext3|ext4|btrfs)
      :
    ;;
    *)
      usage
    ;;
  esac
}

checkparm() {
  case "$1" in
    -*)
      echo "E: Need an argument" >&2
      usage
    ;;
  esac
}

consoles=""

# parse commandline options
while [ ! -z "$1" ]; do
  case "$1" in
    -h|--help)
      usage
      ;;
    --hwpack)
      checkparm "$2"
      HWPACK_FILES[${#HWPACK_FILES[@]}]="$2"
      ;;
    --hwpack-force-yes)
      HWPACK_FORCE_YES="yes"
      ;;
    --mmc)
      checkparm "$2"
      DEVICE="$2"
      check_device
      ;;
    --image_file)
      checkparm "$2"
      IMAGE_FILE="$2"
      ;;
    --image_size)
      checkparm "$2"
      IMAGE_SIZE=$2
      ;;
    --rootfs)
      checkparm "$2"
      RFS="$2"
      check_fs_type
      ;;
    --boot_label)
      checkparm "$2"
      BOOT_LABEL="$2"
      ;;
    --rfs_label)
      checkparm "$2"
      RFS_LABEL="$2"
      ;;
    --swap_file)
      checkparm "$2"
      SWAP_SIZE="$2"
      CREATE_SWAP=1
      ;;
    --live)
      IS_LIVE=1
      ;;
    --live-256m)
      IS_LIVE=1
      IS_LOWMEM=1
      ;;
    --console)
      checkparm "$2"
      consoles="$consoles $2"
      ;;
    --dev)
      checkparm "$2"
      DEVIMAGE=$2
      ;;
    --binary)
      checkparm "$2"
      BINARY_TARBALL="$2"
      ;;
    --no-rootfs)
      ROOTFS_STEP=""
      ;;
    --no-bootfs)
      BOOTFS_STEP=""
      ;;
    --no-part)
      SHOULD_CREATE_PARTITIONS="no"
      ;;
  esac
  shift
done

DEPLOY_STEPS="setup_partitions $BOOTFS_STEP $ROOTFS_STEP"

python -m media_create.ensure_command mkimage uboot-mkimage
python -m media_create.ensure_command uuidgen uuid-runtime
python -m media_create.ensure_command parted parted
case "$RFS" in
  ext2|ext3|ext4)
    python -m media_create.ensure_command "mkfs.$RFS" e2fsprogs
    ;;
  btrfs)
    python -m media_create.ensure_command mkfs.btrfs btrfs-tools
    ;;
esac

case "$DEVIMAGE" in
  beagle)
    UBOOT_FLAVOR="omap3_beagle"
  ;;
  panda)
    UBOOT_FLAVOR="omap4_panda"
  ;;    
  vexpress)
    UBOOT_FLAVOR="ca9x4_ct_vxp"
  ;;
esac

RFS_UUID=`uuidgen -r`

install_hwpacks () {
  chroot=${DIR}/binary
  # Make sure we unmount /proc in the chroot or else it can't be moved to the
  # rootfs.

  LINARO_HWPACK_INSTALL=$(which linaro-hwpack-install)

  sudo mv -f ${chroot}/etc/resolv.conf ${TMP_DIR}/resolv.conf.orig
  sudo cp /etc/resolv.conf ${chroot}/etc/resolv.conf

  sudo mv -f ${chroot}/etc/hosts ${TMP_DIR}/hosts.orig
  sudo cp /etc/hosts ${chroot}/etc/hosts

  local arch_is_arm=no
  case `uname -m` in
    arm*)
      arch_is_arm=yes
      ;;
    *)
      python -m media_create.ensure_command qemu-arm-static qemu-arm-static
      python -m media_create.ensure_command qemu-img qemu-kvm
      sudo cp /usr/bin/qemu-arm-static ${chroot}/usr/bin
      ;;
  esac
  sudo cp "$LINARO_HWPACK_INSTALL" "${chroot}/usr/bin"

  # Actually install the hwpack.
  sudo mount proc ${chroot}/proc -t proc
  cleanup_chroot() {
    sudo umount -v "$chroot/proc"
  }

  for HWPACK_FILE in "${HWPACK_FILES[@]}"; do

    sudo cp "$HWPACK_FILE" "$chroot"
    echo ""
    echo "---------------------------------------------------"
    echo "Installing (apt-get) $HWPACK_FILE in target rootfs."
    echo ""
    if [ "$HWPACK_FORCE_YES" = "yes" ]; then
      sudo LC_ALL=C chroot "$chroot" linaro-hwpack-install --force-yes /"$(basename "$HWPACK_FILE")"
    else
      sudo LC_ALL=C chroot "$chroot" linaro-hwpack-install /"$(basename "$HWPACK_FILE")"
    fi
    echo "---------------------------------------------------"
    echo ""
    sudo rm -f "${chroot}/$(basename "$HWPACK_FILE")"

  done

  # Revert some changes we did to the rootfs as we don't want them in the
  # image.
  sudo umount ${chroot}/proc
  cleanup_chroot() { :; }

  sudo mv -f ${TMP_DIR}/resolv.conf.orig ${chroot}/etc/resolv.conf
  sudo mv -f ${TMP_DIR}/hosts.orig ${chroot}/etc/hosts
  if [ "arch_is_arm" = no ]; then
    sudo rm -f ${chroot}/usr/bin/qemu-arm-static
  fi
  sudo rm -f ${chroot}/usr/bin/linaro-hwpack-install
}

unpack_binary_tarball() {
  # Remove the binary/ directory so that previous runs don't interfere here.
  python -m media_create.remove_binary_dir
  python -m media_create.unpack_binary_tarball "$BINARY_TARBALL"
}

create_boot_cmd() {
  python -m media_create.boot_cmd $IS_LIVE $IS_LOWMEM "$mmc_option" \
    "$RFS_UUID" "$KERNEL_ADDR" "$INITRD_ADDR" "$serial_opts" \
    "$boot_args_options" "$splash_opts" > ${TMP_DIR}/boot.cmd
}

cleanup_sd() {

  echo ""
  echo "Umounting Partitions"
  echo ""

  if test -n "$BOOTFS"; then
    sudo umount ${BOOTFS} &> /dev/null || true
  fi
  if test -n "$ROOTFS"; then
    sudo umount ${ROOTFS} &> /dev/null || true
  fi
}

loop_devices=

cleanup_loopbacks() {

  local d

  if [ -n "$loop_devices" ]; then

    echo
    echo "Releasing loop devices."

    for d in $loop_devices; do
      if [ -n "$d" ]; then
        sudo losetup -d "$d"
      fi
    done

  fi
}

register_loopback() {
  loop_devices="$loop_devices $1"
}

setup_partitions() {
  boot_and_root_devices=$(python -m media_create.partitions \
      "$DEVIMAGE" "${DEVICE-$IMAGE_FILE}" "$FAT_SIZE" "$IMAGE_SIZE" \
      "$BOOT_LABEL" "$RFS_LABEL" "$RFS" "$RFS_UUID" \
      "$SHOULD_CREATE_PARTITIONS" "$BOOTFS_STEP" "$ROOTFS_STEP")
  eval $boot_and_root_devices

  if [ "${IMAGE_FILE}" ]; then
    register_loopback "$BOOTFS"
    register_loopback "$ROOTFS"
  fi
}

populate_boot() {
  echo ""
  echo "Populating Boot Partition"
  echo ""
 
  echo ""
  echo "Installing Boot Loader"
  echo ""
 
  if [ "$IS_LIVE" -eq 1 ]; then
    parts_dir="${DIR}/binary/casper"
  else
    parts_dir="${DIR}/binary/boot"
  fi
 
  mkdir -p "${BOOT_DISK}"
  sudo mount ${BOOTFS} "${BOOT_DISK}"

  if [ -n "$UBOOT_FLAVOR" ]; then
      sudo cp -v "binary/usr/lib/u-boot/${UBOOT_FLAVOR}/u-boot.bin" \
               "${BOOT_DISK}"
  fi

  python -m media_create.populate_boot "$DEVIMAGE" "$SUB_ARCH" "$LOAD_ADDR" \
    "$parts_dir" "$BOOT_DISK" "$TMP_DIR" "$BOOT_SCRIPT" \
    "${DEVICE:-$IMAGE_FILE}"

  sync
  sync
  sudo umount "${BOOT_DISK}" || true
}

populate_rootfs() {
  echo ""
  echo "Populating rootfs Partition"
  echo "Be patient, this may take a few minutes"
  echo ""
  mkdir -p "${ROOT_DISK}"
  sudo mount ${ROOTFS} "${ROOT_DISK}"

  sudo mv ${DIR}/binary/* "$ROOT_DISK"

  # add fstab entry for rootfs and boot
  echo "UUID=${RFS_UUID} / ${RFS}  errors=remount-ro 0 1 " | sudo tee -a "${ROOT_DISK}/etc/fstab"

  if [ "$CREATE_SWAP" ] ; then

    echo ""
    echo "Creating SWAP File"
    echo ""

    SPACE_LEFT=$(LC_ALL=C df "${ROOT_DISK}" | grep ${ROOTFS} | awk '{print $4}')

    let SIZE=$SWAP_SIZE*1024

    if [ $SPACE_LEFT -ge $SIZE ] ; then
      sudo dd if=/dev/zero "of=${ROOT_DISK}/SWAP.swap" bs=1M count=$SWAP_SIZE
      sudo mkswap "${ROOT_DISK}/SWAP.swap"
      echo "/SWAP.swap  none  swap  sw  0 0" | sudo tee -a "${ROOT_DISK}/etc/fstab"
    else
      echo "SWAP file bigger then whats left on partition"
    fi
  fi

  echo ""
  echo "Creating /etc/flash-kernel.conf"
  echo ""

  TARGET_BOOT_DEV=/dev/mmcblk0p$(( 1 + $MMC_PART_OFFSET ))
  echo "UBOOT_PART=${TARGET_BOOT_DEV}" | sudo tee "${ROOT_DISK}/etc/flash-kernel.conf" >/dev/null

  sync
  sync
  sudo umount "${ROOT_DISK}" || true
}

remove_image_file() {
  if [ -f "$IMAGE_FILE" ]; then
    rm -v $IMAGE_FILE
  fi
}

signal_handler() {
  cleanup_handler
  exit 2
}

# Initially, no action is needed to clean up mounts in the chroot.
# install_hwpack will temporarily define this function when needed.
cleanup_chroot() { :; }

cleanup_handler() {
  status=$?

  trap - EXIT INT TERM

  set +e

  if [ $status != 0 ]; then
    echo >&2 "$0: FAILED"
  fi

  echo
  echo "Performing cleanup..."
  echo

  cleanup_chroot
  cleanup_sd
  cleanup_mountpoints
  cleanup_tempfiles
  cleanup_loopbacks
  python -m media_create.remove_binary_dir

  if [ "$status" != 0 ]; then
      remove_image_file
  fi

  # According to POSIX, for the EXIT trap the shell will now exit with the
  # exit status of the failing command which triggered the EXIT, or 0 if the
  # script terminated successfully.

  # For the INT/TERM trap, return to signal_handler.
}

# Call cleanup_handler as appropriate.
# The EXIT trap gets called both on normal exit or exit-on-error (set -e)
# so we get called either way.
trap cleanup_handler EXIT
trap signal_handler INT TERM

serial_opts=""
if [ "$consoles" ]; then
  for c in ${consoles}; do
    serial_opts="$serial_opts console=$c"
  done
  if [ "$IS_LIVE" -eq 1 ]; then
    serial_opts="$serial_opts serialtty=ttyS2"
  fi
fi

case "$DEVIMAGE" in
  beagle|igep|mx51evk|panda|ux500|vexpress)
    :
  ;;
  "")
    echo "Please set some target device with --dev" >&2
    usage
  ;;
  *)
    echo "Unknown target device $DEVIMAGE" >&2
    usage
  ;;
esac

# This whole thing will be moved into config files that will be specific for
# each board.
if [ "$DEVIMAGE" ]; then
  case "$DEVIMAGE" in
    beagle|igep)
      serial_opts="$serial_opts console=tty0 console=ttyS2,115200n8"
      if [ "$IS_LIVE" -eq 1 ]; then
        serial_opts="$serial_opts serialtty=ttyS2"
      fi
      KERNEL_ADDR="0x80000000"
      INITRD_ADDR="0x81600000"
      LOAD_ADDR="0x80008000"
      SUB_ARCH="linaro-omap"
      BOOT_SCRIPT="boot.scr"
      boot_args_options="$boot_args_options earlyprintk fixrtc nocompcache vram=12M omapfb.debug=y omapfb.mode=dvi:1280x720MR-16@60"
      ;;
    panda)
      serial_opts="$serial_opts console=tty0 console=ttyO2,115200n8"
      if [ "$IS_LIVE" -eq 1 ]; then
        serial_opts="$serial_opts serialtty=ttyO2"
      fi
      KERNEL_ADDR="0x80200000"
      INITRD_ADDR="0x81600000"
      LOAD_ADDR="0x80008000"
      SUB_ARCH="omap4"
      BOOT_SCRIPT="boot.scr"
      boot_args_options="$boot_args_options earlyprintk fixrtc nocompcache vram=32M omapfb.debug=y omapfb.vram=0:8M mem=463M ip=none"
      ;;
    ux500)
      serial_opts="$serial_opts console=tty0 console=ttyAMA2,115200n8"
      if [ "$IS_LIVE" -eq 1 ]; then
        serial_opts="$serial_opts serialtty=ttyAMA2"
      fi
      KERNEL_ADDR="0x00100000"
      INITRD_ADDR="0x08000000"
      LOAD_ADDR="0x00008000"
      SUB_ARCH="ux500"
      BOOT_SCRIPT="flash.scr"
      boot_args_options="$boot_args_options earlyprintk rootdelay=1 fixrtc nocompcache"
      boot_args_options="$boot_args_options mem=96M@0 mem_modem=32M@96M mem=44M@128M pmem=22M@172M mem=30M@194M mem_mali=32M@224M pmem_hwb=54M@256M hwmem=48M@302M mem=152M@360M"
      mmc_option="1:1"
      ;;
    mx51evk)
      serial_opts="$serial_opts console=tty0 console=ttymxc0,115200n8"
      if [ "$IS_LIVE" -eq 1 ]; then
        serial_opts="$serial_opts serialtty=ttymxc0"
      fi
      KERNEL_ADDR="0x90000000"
      INITRD_ADDR="0x90800000"
      LOAD_ADDR="0x90008000"
      SUB_ARCH="linaro-mx51"
      BOOT_SCRIPT="boot.scr"
      MMC_PART_OFFSET=1
      mmc_option="0:2"
      ;;
    vexpress)
      serial_opts="$serial_opts console=tty0 console=ttyAMA0,38400n8"
      if [ "$IS_LIVE" -eq 1 ]; then
        serial_opts="$serial_opts serialtty=ttyAMA0"
      fi
      KERNEL_ADDR="0x60008000"
      INITRD_ADDR="0x81000000"
      LOAD_ADDR=$KERNEL_ADDR
      SUB_ARCH="linaro-vexpress"
      # ARM Boot Monitor is used to load u-boot, uImage etc. into flash and
      # only allows for FAT16
      FAT_SIZE=16
      ;;
    *)
      echo "Internal error; missing support for $DEVIMAGE" >&2
      exit 1
      ;;
  esac
else
  if [ "$IS_LIVE" -eq 1 ]; then
    splash_opts="quiet splash"
  fi
fi

if [ ! "${DEVICE}" -a ! "${IMAGE_FILE}" ]; then
  usage
fi

# The bootfs and rootfs deploy options are only available with physical 
# devices.  These options are intended for deploying to different devices like
# a USB drive and an MMC device.  The options do not apply to qemu image_files.
if [ "${IMAGE_FILE}" ]; then
  if [ -z "${ROOTFS_STEP}" ] || [ -z "${BOOTFS_STEP}" ]; then
    echo "Do not use --no-rootfs or --no-bootfs with the --image_file option"
    exit
  fi
fi

unpack_binary_tarball
if [ "${#HWPACK_FILES[@]}" -gt 0 ]; then
  install_hwpacks
else
  echo "Warning, --hwpack <filename> was not specified, the result is unlikely to be functional without manual effort to setup uImage, MLO, u-boot.bin and so as as appropriate for your hardware."
fi
for func in $DEPLOY_STEPS; do
  $func
done

