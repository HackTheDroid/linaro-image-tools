#!/bin/bash
# linaro-hwpack-install - Install a Linaro Hardware Pack.
#   This script is meant to run inside a chroot containing nothing other than
#   ubuntu-minimal, so it must not depend on anything that's not in
#   there.
# TODO: When upgrading to a newer hwpack, make sure packages and apt sources
# that are no longer needed are removed.

# Copyright (C) 2010, 2011 Linaro
#
# Author: Guilherme Salgado <guilherme.salgado@linaro.org>
#
# This file is part of Linaro Image Tools.
#
# Linaro Image Tools is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# Linaro Image Tools is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with Linaro Image Tools; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
# USA.

set -e

if [ -n "${TMPDIR+x}" ]; then
 echo -e "\nWARNING: TMPDIR variable is set. It will be unset because in chroot environment it likely doesn't exist and can lead to error messages.\n"
 unset TMPDIR
fi

LOCKFILE="/var/lock/hwpack"
TEMP_DIR=$(mktemp -d)
HWPACK_DIR="${TEMP_DIR}/unpacked"
INSTALL_LATEST="no"
FORCE_YES="no"
SOURCES_LIST_FILE="${TEMP_DIR}/sources.list"
APT_GET_OPTIONS="Dir::Etc::SourceList=${SOURCES_LIST_FILE}"
SUPPORTED_FORMATS="1.0 2.0 3.0"  # A space-separated list of hwpack formats.

sudo="sudo"
if [ $(id -u) -eq 0 ]; then
    sudo=""
fi

die() {
  echo -e "$@"
  exit 1
}

usage_msg="Usage: $(basename $0) [--install-latest] [--force-yes] HWPACK_TARBALL"
if [ $# -eq 0 ]; then
  die $usage_msg
fi

HWPACK_TARBALL_FOUND="no"

while [ $# -gt 0 ]; do
  case "$1" in 
    --install-latest)
      INSTALL_LATEST="yes"
      shift;;
    --force-yes)
      FORCE_YES="yes"
      shift;;
    --*)
      die $usage_msg "\nUnrecognized option: \"$1\"";;
    *)
      [ "$HWPACK_TARBALL_FOUND" = "yes" ] && die $usage_msg
      HWPACK_TARBALL="$1"
      HWPACK_TARBALL_FOUND="yes"
      shift;;
  esac
done

[ "$HWPACK_TARBALL_FOUND" = "no" ] && die $usage_msg

# Try to acquire fd #9 (i.e. /var/lock/hwpack) for 2 seconds.
# Using 9 as the file descriptor because of https://launchpad.net/bugs/249620
exec 9>$LOCKFILE
flock -w2 9 || die "Could not acquire lock: $LOCKFILE"

cleanup() {
  # Ensure our temp dir and apt sources are removed.
  echo -n "Cleaning up ..."
  rm -rf $TEMP_DIR
  rm -f /usr/sbin/policy-rc.d
  mv -f /sbin/start-stop-daemon.REAL /sbin/start-stop-daemon
  if [ -x /sbin/initctl.REAL ]; then
    mv -f /sbin/initctl.REAL /sbin/initctl
  fi
  $sudo apt-get update -qq
  echo "Done"
}

# From now on we'll be making changes to the system, so we need to clean
# things up when the script exits.
trap cleanup EXIT

# This creates all the directories we need.
mkdir -p "$HWPACK_DIR"

# Unpack the hwpack tarball. We don't download it here because the chroot may
# not contain any tools that would allow us to do that.
echo -n "Unpacking hardware pack ..."
tar zxf "$HWPACK_TARBALL" -C "$HWPACK_DIR"
echo "Done"

function query_v3_metadata {
  python -c "import re
with open('${HWPACK_DIR}/metadata') as configv3:
    config = {}  # Will store decoded YAML in here
    root = config   # Current insert point for adding data
    root_at_indent = {}
    indent = 0
    for line in configv3.readlines():
        key_value = re.search('^(\s*)(\S.+):\s+(.+)\s*$', line)
        key_match = re.search('^(\s*)(\S.+):\s*$', line)
        list_item = re.search('^(\s*)-\s*(.+)\s*$', line)

        if key_value:
            new_indent = len(key_value.group(1))
        elif key_match:
            new_indent = len(key_match.group(1))
        elif list_item:
            new_indent = len(list_item.group(1))

        if new_indent < indent:  #Indent decreases: go back up config structure
            root = root_at_indent[new_indent]
        elif new_indent > indent:  # Indent increases: reset root (insert point)
            root_at_indent[indent] = root
            root = root[key]
        indent = new_indent

        if key_value:  # key: value
            key = key_value.group(2)
            root[key] = key_value.group(3)
        elif key_match:  # key:
            key = key_match.group(2)
            root[key] = {}
        elif list_item:  # - value
            # If the list has extra indentation then root == {}
            # If the list doesn't have extra indentation, root = {key: {}}
            # We need to create a list in that empty dictionary. Work out
            # where it is, assign it to insert_point.
            insert_point = None
            if root == {}:
                insert_point = root
            keys = root.keys()
            if len(keys) == 1:
                insert_point = root[keys[0]]

            if insert_point == {}:
                insert_point[''] = []

            insert_point[''].append(list_item.group(2))

    keys = '$1'.split(' ')
    for key in keys:
        if isinstance(config, list):
            key = int(key)
        config = config[key]
        if(isinstance(config, dict) and
           '' in config and
           isinstance(config[''], list)):
            config = config['']
    print config
  "
}

# Check the format of the hwpack is supported.
hwpack_format=$(cat ${HWPACK_DIR}/FORMAT)
supported="false"
for format in $SUPPORTED_FORMATS; do
  if [ $hwpack_format == $format ]; then
    supported="true"
    break
  fi
done
[ $supported == "true" ] || \
  die "Unsupported hwpack format: $hwpack_format. "\
      "Try using a newer version of $(basename $0)."

# Check the architecture of the hwpack matches that of the host system.
HWPACK_VERSION=`grep VERSION "${HWPACK_DIR}/metadata" | cut -d "=" -f2`
if [ "$HWPACK_VERSION" = "" ]; then
  HWPACK_VERSION=$(query_v3_metadata 'version')
fi

if [ "$hwpack_format" = "3.0" ]; then
  HWPACK_ARCH=$(query_v3_metadata 'architecture')
else
  HWPACK_ARCH=`grep ARCHITECTURE "${HWPACK_DIR}/metadata" | cut -d "=" -f2`
fi

[ "$HWPACK_ARCH" == `dpkg --print-architecture` ] || \
  die "Hardware pack architecture ($HWPACK_ARCH) does not match the host's architecture"

# Install the apt sources that contain the packages we need.
for filename in $(ls "${HWPACK_DIR}"/sources.list.d/); do
  file="${HWPACK_DIR}"/sources.list.d/$filename
  should_install=0
  stripped_file=${TEMP_DIR}/$filename
  grep -v "\(^#\|^\s*$\)" $file > $stripped_file
  while read line; do
    # Only install files that have at least one line not present in the
    # existing sources lists.
    grep -qF "$line" $(find /etc/apt/sources.list.d/ -name '*.list') /etc/apt/sources.list \
      || should_install=1
  done < $stripped_file

  if [ $should_install -eq 1 ]; then
    $sudo cp $file /etc/apt/sources.list.d/hwpack.$filename
  fi
done

# Import the OpenPGP keys for the files installed above.
for filename in $(ls "${HWPACK_DIR}"/sources.list.d.gpg/); do
  file="${HWPACK_DIR}"/sources.list.d.gpg/$filename
  $sudo apt-key add $file
done

# Prevent daemons to start in the chroot
echo "exit 101" > /usr/sbin/policy-rc.d
chmod a+x /usr/sbin/policy-rc.d

mv -f /sbin/start-stop-daemon /sbin/start-stop-daemon.REAL
cat > /sbin/start-stop-daemon << EOF
#!/bin/sh

echo "Warning: Fake start-stop-daemon called, doing nothing"
EOF
chmod 755 /sbin/start-stop-daemon

if [ -x /sbin/initctl ]; then
  mv -f /sbin/initctl /sbin/initctl.REAL
  cat > /sbin/initctl << EOF
#!/bin/sh

echo "Warning: Fake initctl called, doing nothing"
EOF
  chmod 755 /sbin/initctl
fi

# Add one extra apt source for the packages included in the hwpack and make
# sure it's the first on the list of sources so that it gets precedence over
# the others.
echo "deb file:${HWPACK_DIR}/pkgs ./" > "$SOURCES_LIST_FILE"
cat /etc/apt/sources.list >> "$SOURCES_LIST_FILE"

if [ "$FORCE_YES" == "yes" ]; then
  FORCE_OPTIONS="--yes --force-yes"
else
  FORCE_OPTIONS=""
fi

echo "Updating apt package lists ..."
$sudo apt-get $FORCE_OPTIONS -o "$APT_GET_OPTIONS" update -q

echo -n "Installing packages ..."

# "newer" hwpacks contain a dependency package whose Depends is the
# same as the packages config setting from the file the hwpack was
# build from.  But if we just installed that, a newer version of a
# package than that in the hwpack might have made it to the main
# archive and apt-get would install that instead.  So we install the
# specific package versions that make up the hwpack.  /That/ however
# would leave all the packages from the hwpack marked as manually
# installed, so if a newer hwpack was installed over the top which no
# longer depended on one of the packages the older one did, the
# package would not be eligible for autoremoval.  So we mark the all
# packages newly installed as part of hwpack installed (apart from the
# dependency package) as automatically installed with apt-get
# markauto.
#
# For "older" hwpacks that don't have a dependency package, we just
# manually install the contents of the hwpack.

if [ "hwpack_format" = "3.0" ]; then
  HWPACK_NAME=$(query_v3_metadata 'name')
else
  HWPACK_NAME=`grep NAME "${HWPACK_DIR}/metadata" | cut -d "=" -f2`
fi

dependency_package="hwpack-${HWPACK_NAME}"
if grep -q "^${dependency_package}=${HWPACK_VERSION}\$" "${HWPACK_DIR}"/manifest; then
  DEP_PACKAGE_PRESENT="yes"
else
  DEP_PACKAGE_PRESENT="no"
fi

packages_without_versions=`sed 's/=.*//' "${HWPACK_DIR}"/manifest`
packages_with_versions=`cat "${HWPACK_DIR}"/manifest`

if [ "$INSTALL_LATEST" == "yes" ]; then
  packages="${packages_without_versions}"
else
  packages="${packages_with_versions}"
fi

if [ "$DEP_PACKAGE_PRESENT" == "yes" ]; then
  to_be_installed=
  for package in $packages_without_versions; do
    if [ "${package}" != "${dependency_package}" ]; then
      { dpkg --get-selections $package 2>/dev/null| grep -qw 'install$'; } || to_be_installed="$to_be_installed $package"
    fi
  done
fi

$sudo apt-get $FORCE_OPTIONS -o "$APT_GET_OPTIONS" install ${packages}

if [ "$DEP_PACKAGE_PRESENT" == "yes" ]; then
  if [ -n "${to_be_installed}" ]; then
    $sudo apt-get $FORCE_OPTIONS -o "$APT_GET_OPTIONS" markauto ${to_be_installed}
  fi
fi

echo "Done"
